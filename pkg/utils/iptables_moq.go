// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package utils

import (
	"github.com/coreos/go-iptables/iptables"
	"sync"
)

// Ensure, that IPTablesHandlerMock does implement IPTablesHandler.
// If this is not the case, regenerate this file with moq.
var _ IPTablesHandler = &IPTablesHandlerMock{}

// IPTablesHandlerMock is a mock implementation of IPTablesHandler.
//
//	func TestSomethingThatUsesIPTablesHandler(t *testing.T) {
//
//		// make and configure a mocked IPTablesHandler
//		mockedIPTablesHandler := &IPTablesHandlerMock{
//			AppendFunc: func(table string, chain string, rulespec ...string) error {
//				panic("mock out the Append method")
//			},
//			AppendUniqueFunc: func(table string, chain string, rulespec ...string) error {
//				panic("mock out the AppendUnique method")
//			},
//			ChainExistsFunc: func(table string, chain string) (bool, error) {
//				panic("mock out the ChainExists method")
//			},
//			ChangePolicyFunc: func(table string, chain string, target string) error {
//				panic("mock out the ChangePolicy method")
//			},
//			ClearAllFunc: func() error {
//				panic("mock out the ClearAll method")
//			},
//			ClearAndDeleteChainFunc: func(table string, chain string) error {
//				panic("mock out the ClearAndDeleteChain method")
//			},
//			ClearChainFunc: func(table string, chain string) error {
//				panic("mock out the ClearChain method")
//			},
//			DeleteFunc: func(table string, chain string, rulespec ...string) error {
//				panic("mock out the Delete method")
//			},
//			DeleteAllFunc: func() error {
//				panic("mock out the DeleteAll method")
//			},
//			DeleteChainFunc: func(table string, chain string) error {
//				panic("mock out the DeleteChain method")
//			},
//			DeleteIfExistsFunc: func(table string, chain string, rulespec ...string) error {
//				panic("mock out the DeleteIfExists method")
//			},
//			ExistsFunc: func(table string, chain string, rulespec ...string) (bool, error) {
//				panic("mock out the Exists method")
//			},
//			GetIptablesVersionFunc: func() (int, int, int) {
//				panic("mock out the GetIptablesVersion method")
//			},
//			HasRandomFullyFunc: func() bool {
//				panic("mock out the HasRandomFully method")
//			},
//			InsertFunc: func(table string, chain string, pos int, rulespec ...string) error {
//				panic("mock out the Insert method")
//			},
//			ListFunc: func(table string, chain string) ([]string, error) {
//				panic("mock out the List method")
//			},
//			ListChainsFunc: func(table string) ([]string, error) {
//				panic("mock out the ListChains method")
//			},
//			ListWithCountersFunc: func(table string, chain string) ([]string, error) {
//				panic("mock out the ListWithCounters method")
//			},
//			NewChainFunc: func(table string, chain string) error {
//				panic("mock out the NewChain method")
//			},
//			ParseStatFunc: func(stat []string) (iptables.Stat, error) {
//				panic("mock out the ParseStat method")
//			},
//			ProtoFunc: func() iptables.Protocol {
//				panic("mock out the Proto method")
//			},
//			RenameChainFunc: func(table string, oldChain string, newChain string) error {
//				panic("mock out the RenameChain method")
//			},
//			StatsFunc: func(table string, chain string) ([][]string, error) {
//				panic("mock out the Stats method")
//			},
//			StructuredStatsFunc: func(table string, chain string) ([]iptables.Stat, error) {
//				panic("mock out the StructuredStats method")
//			},
//		}
//
//		// use mockedIPTablesHandler in code that requires IPTablesHandler
//		// and then make assertions.
//
//	}
type IPTablesHandlerMock struct {
	// AppendFunc mocks the Append method.
	AppendFunc func(table string, chain string, rulespec ...string) error

	// AppendUniqueFunc mocks the AppendUnique method.
	AppendUniqueFunc func(table string, chain string, rulespec ...string) error

	// ChainExistsFunc mocks the ChainExists method.
	ChainExistsFunc func(table string, chain string) (bool, error)

	// ChangePolicyFunc mocks the ChangePolicy method.
	ChangePolicyFunc func(table string, chain string, target string) error

	// ClearAllFunc mocks the ClearAll method.
	ClearAllFunc func() error

	// ClearAndDeleteChainFunc mocks the ClearAndDeleteChain method.
	ClearAndDeleteChainFunc func(table string, chain string) error

	// ClearChainFunc mocks the ClearChain method.
	ClearChainFunc func(table string, chain string) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(table string, chain string, rulespec ...string) error

	// DeleteAllFunc mocks the DeleteAll method.
	DeleteAllFunc func() error

	// DeleteChainFunc mocks the DeleteChain method.
	DeleteChainFunc func(table string, chain string) error

	// DeleteIfExistsFunc mocks the DeleteIfExists method.
	DeleteIfExistsFunc func(table string, chain string, rulespec ...string) error

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(table string, chain string, rulespec ...string) (bool, error)

	// GetIptablesVersionFunc mocks the GetIptablesVersion method.
	GetIptablesVersionFunc func() (int, int, int)

	// HasRandomFullyFunc mocks the HasRandomFully method.
	HasRandomFullyFunc func() bool

	// InsertFunc mocks the Insert method.
	InsertFunc func(table string, chain string, pos int, rulespec ...string) error

	// ListFunc mocks the List method.
	ListFunc func(table string, chain string) ([]string, error)

	// ListChainsFunc mocks the ListChains method.
	ListChainsFunc func(table string) ([]string, error)

	// ListWithCountersFunc mocks the ListWithCounters method.
	ListWithCountersFunc func(table string, chain string) ([]string, error)

	// NewChainFunc mocks the NewChain method.
	NewChainFunc func(table string, chain string) error

	// ParseStatFunc mocks the ParseStat method.
	ParseStatFunc func(stat []string) (iptables.Stat, error)

	// ProtoFunc mocks the Proto method.
	ProtoFunc func() iptables.Protocol

	// RenameChainFunc mocks the RenameChain method.
	RenameChainFunc func(table string, oldChain string, newChain string) error

	// StatsFunc mocks the Stats method.
	StatsFunc func(table string, chain string) ([][]string, error)

	// StructuredStatsFunc mocks the StructuredStats method.
	StructuredStatsFunc func(table string, chain string) ([]iptables.Stat, error)

	// calls tracks calls to the methods.
	calls struct {
		// Append holds details about calls to the Append method.
		Append []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
			// Rulespec is the rulespec argument value.
			Rulespec []string
		}
		// AppendUnique holds details about calls to the AppendUnique method.
		AppendUnique []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
			// Rulespec is the rulespec argument value.
			Rulespec []string
		}
		// ChainExists holds details about calls to the ChainExists method.
		ChainExists []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
		}
		// ChangePolicy holds details about calls to the ChangePolicy method.
		ChangePolicy []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
			// Target is the target argument value.
			Target string
		}
		// ClearAll holds details about calls to the ClearAll method.
		ClearAll []struct {
		}
		// ClearAndDeleteChain holds details about calls to the ClearAndDeleteChain method.
		ClearAndDeleteChain []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
		}
		// ClearChain holds details about calls to the ClearChain method.
		ClearChain []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
			// Rulespec is the rulespec argument value.
			Rulespec []string
		}
		// DeleteAll holds details about calls to the DeleteAll method.
		DeleteAll []struct {
		}
		// DeleteChain holds details about calls to the DeleteChain method.
		DeleteChain []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
		}
		// DeleteIfExists holds details about calls to the DeleteIfExists method.
		DeleteIfExists []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
			// Rulespec is the rulespec argument value.
			Rulespec []string
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
			// Rulespec is the rulespec argument value.
			Rulespec []string
		}
		// GetIptablesVersion holds details about calls to the GetIptablesVersion method.
		GetIptablesVersion []struct {
		}
		// HasRandomFully holds details about calls to the HasRandomFully method.
		HasRandomFully []struct {
		}
		// Insert holds details about calls to the Insert method.
		Insert []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
			// Pos is the pos argument value.
			Pos int
			// Rulespec is the rulespec argument value.
			Rulespec []string
		}
		// List holds details about calls to the List method.
		List []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
		}
		// ListChains holds details about calls to the ListChains method.
		ListChains []struct {
			// Table is the table argument value.
			Table string
		}
		// ListWithCounters holds details about calls to the ListWithCounters method.
		ListWithCounters []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
		}
		// NewChain holds details about calls to the NewChain method.
		NewChain []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
		}
		// ParseStat holds details about calls to the ParseStat method.
		ParseStat []struct {
			// Stat is the stat argument value.
			Stat []string
		}
		// Proto holds details about calls to the Proto method.
		Proto []struct {
		}
		// RenameChain holds details about calls to the RenameChain method.
		RenameChain []struct {
			// Table is the table argument value.
			Table string
			// OldChain is the oldChain argument value.
			OldChain string
			// NewChain is the newChain argument value.
			NewChain string
		}
		// Stats holds details about calls to the Stats method.
		Stats []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
		}
		// StructuredStats holds details about calls to the StructuredStats method.
		StructuredStats []struct {
			// Table is the table argument value.
			Table string
			// Chain is the chain argument value.
			Chain string
		}
	}
	lockAppend              sync.RWMutex
	lockAppendUnique        sync.RWMutex
	lockChainExists         sync.RWMutex
	lockChangePolicy        sync.RWMutex
	lockClearAll            sync.RWMutex
	lockClearAndDeleteChain sync.RWMutex
	lockClearChain          sync.RWMutex
	lockDelete              sync.RWMutex
	lockDeleteAll           sync.RWMutex
	lockDeleteChain         sync.RWMutex
	lockDeleteIfExists      sync.RWMutex
	lockExists              sync.RWMutex
	lockGetIptablesVersion  sync.RWMutex
	lockHasRandomFully      sync.RWMutex
	lockInsert              sync.RWMutex
	lockList                sync.RWMutex
	lockListChains          sync.RWMutex
	lockListWithCounters    sync.RWMutex
	lockNewChain            sync.RWMutex
	lockParseStat           sync.RWMutex
	lockProto               sync.RWMutex
	lockRenameChain         sync.RWMutex
	lockStats               sync.RWMutex
	lockStructuredStats     sync.RWMutex
}

// Append calls AppendFunc.
func (mock *IPTablesHandlerMock) Append(table string, chain string, rulespec ...string) error {
	if mock.AppendFunc == nil {
		panic("IPTablesHandlerMock.AppendFunc: method is nil but IPTablesHandler.Append was just called")
	}
	callInfo := struct {
		Table    string
		Chain    string
		Rulespec []string
	}{
		Table:    table,
		Chain:    chain,
		Rulespec: rulespec,
	}
	mock.lockAppend.Lock()
	mock.calls.Append = append(mock.calls.Append, callInfo)
	mock.lockAppend.Unlock()
	return mock.AppendFunc(table, chain, rulespec...)
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//
//	len(mockedIPTablesHandler.AppendCalls())
func (mock *IPTablesHandlerMock) AppendCalls() []struct {
	Table    string
	Chain    string
	Rulespec []string
} {
	var calls []struct {
		Table    string
		Chain    string
		Rulespec []string
	}
	mock.lockAppend.RLock()
	calls = mock.calls.Append
	mock.lockAppend.RUnlock()
	return calls
}

// AppendUnique calls AppendUniqueFunc.
func (mock *IPTablesHandlerMock) AppendUnique(table string, chain string, rulespec ...string) error {
	if mock.AppendUniqueFunc == nil {
		panic("IPTablesHandlerMock.AppendUniqueFunc: method is nil but IPTablesHandler.AppendUnique was just called")
	}
	callInfo := struct {
		Table    string
		Chain    string
		Rulespec []string
	}{
		Table:    table,
		Chain:    chain,
		Rulespec: rulespec,
	}
	mock.lockAppendUnique.Lock()
	mock.calls.AppendUnique = append(mock.calls.AppendUnique, callInfo)
	mock.lockAppendUnique.Unlock()
	return mock.AppendUniqueFunc(table, chain, rulespec...)
}

// AppendUniqueCalls gets all the calls that were made to AppendUnique.
// Check the length with:
//
//	len(mockedIPTablesHandler.AppendUniqueCalls())
func (mock *IPTablesHandlerMock) AppendUniqueCalls() []struct {
	Table    string
	Chain    string
	Rulespec []string
} {
	var calls []struct {
		Table    string
		Chain    string
		Rulespec []string
	}
	mock.lockAppendUnique.RLock()
	calls = mock.calls.AppendUnique
	mock.lockAppendUnique.RUnlock()
	return calls
}

// ChainExists calls ChainExistsFunc.
func (mock *IPTablesHandlerMock) ChainExists(table string, chain string) (bool, error) {
	if mock.ChainExistsFunc == nil {
		panic("IPTablesHandlerMock.ChainExistsFunc: method is nil but IPTablesHandler.ChainExists was just called")
	}
	callInfo := struct {
		Table string
		Chain string
	}{
		Table: table,
		Chain: chain,
	}
	mock.lockChainExists.Lock()
	mock.calls.ChainExists = append(mock.calls.ChainExists, callInfo)
	mock.lockChainExists.Unlock()
	return mock.ChainExistsFunc(table, chain)
}

// ChainExistsCalls gets all the calls that were made to ChainExists.
// Check the length with:
//
//	len(mockedIPTablesHandler.ChainExistsCalls())
func (mock *IPTablesHandlerMock) ChainExistsCalls() []struct {
	Table string
	Chain string
} {
	var calls []struct {
		Table string
		Chain string
	}
	mock.lockChainExists.RLock()
	calls = mock.calls.ChainExists
	mock.lockChainExists.RUnlock()
	return calls
}

// ChangePolicy calls ChangePolicyFunc.
func (mock *IPTablesHandlerMock) ChangePolicy(table string, chain string, target string) error {
	if mock.ChangePolicyFunc == nil {
		panic("IPTablesHandlerMock.ChangePolicyFunc: method is nil but IPTablesHandler.ChangePolicy was just called")
	}
	callInfo := struct {
		Table  string
		Chain  string
		Target string
	}{
		Table:  table,
		Chain:  chain,
		Target: target,
	}
	mock.lockChangePolicy.Lock()
	mock.calls.ChangePolicy = append(mock.calls.ChangePolicy, callInfo)
	mock.lockChangePolicy.Unlock()
	return mock.ChangePolicyFunc(table, chain, target)
}

// ChangePolicyCalls gets all the calls that were made to ChangePolicy.
// Check the length with:
//
//	len(mockedIPTablesHandler.ChangePolicyCalls())
func (mock *IPTablesHandlerMock) ChangePolicyCalls() []struct {
	Table  string
	Chain  string
	Target string
} {
	var calls []struct {
		Table  string
		Chain  string
		Target string
	}
	mock.lockChangePolicy.RLock()
	calls = mock.calls.ChangePolicy
	mock.lockChangePolicy.RUnlock()
	return calls
}

// ClearAll calls ClearAllFunc.
func (mock *IPTablesHandlerMock) ClearAll() error {
	if mock.ClearAllFunc == nil {
		panic("IPTablesHandlerMock.ClearAllFunc: method is nil but IPTablesHandler.ClearAll was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClearAll.Lock()
	mock.calls.ClearAll = append(mock.calls.ClearAll, callInfo)
	mock.lockClearAll.Unlock()
	return mock.ClearAllFunc()
}

// ClearAllCalls gets all the calls that were made to ClearAll.
// Check the length with:
//
//	len(mockedIPTablesHandler.ClearAllCalls())
func (mock *IPTablesHandlerMock) ClearAllCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClearAll.RLock()
	calls = mock.calls.ClearAll
	mock.lockClearAll.RUnlock()
	return calls
}

// ClearAndDeleteChain calls ClearAndDeleteChainFunc.
func (mock *IPTablesHandlerMock) ClearAndDeleteChain(table string, chain string) error {
	if mock.ClearAndDeleteChainFunc == nil {
		panic("IPTablesHandlerMock.ClearAndDeleteChainFunc: method is nil but IPTablesHandler.ClearAndDeleteChain was just called")
	}
	callInfo := struct {
		Table string
		Chain string
	}{
		Table: table,
		Chain: chain,
	}
	mock.lockClearAndDeleteChain.Lock()
	mock.calls.ClearAndDeleteChain = append(mock.calls.ClearAndDeleteChain, callInfo)
	mock.lockClearAndDeleteChain.Unlock()
	return mock.ClearAndDeleteChainFunc(table, chain)
}

// ClearAndDeleteChainCalls gets all the calls that were made to ClearAndDeleteChain.
// Check the length with:
//
//	len(mockedIPTablesHandler.ClearAndDeleteChainCalls())
func (mock *IPTablesHandlerMock) ClearAndDeleteChainCalls() []struct {
	Table string
	Chain string
} {
	var calls []struct {
		Table string
		Chain string
	}
	mock.lockClearAndDeleteChain.RLock()
	calls = mock.calls.ClearAndDeleteChain
	mock.lockClearAndDeleteChain.RUnlock()
	return calls
}

// ClearChain calls ClearChainFunc.
func (mock *IPTablesHandlerMock) ClearChain(table string, chain string) error {
	if mock.ClearChainFunc == nil {
		panic("IPTablesHandlerMock.ClearChainFunc: method is nil but IPTablesHandler.ClearChain was just called")
	}
	callInfo := struct {
		Table string
		Chain string
	}{
		Table: table,
		Chain: chain,
	}
	mock.lockClearChain.Lock()
	mock.calls.ClearChain = append(mock.calls.ClearChain, callInfo)
	mock.lockClearChain.Unlock()
	return mock.ClearChainFunc(table, chain)
}

// ClearChainCalls gets all the calls that were made to ClearChain.
// Check the length with:
//
//	len(mockedIPTablesHandler.ClearChainCalls())
func (mock *IPTablesHandlerMock) ClearChainCalls() []struct {
	Table string
	Chain string
} {
	var calls []struct {
		Table string
		Chain string
	}
	mock.lockClearChain.RLock()
	calls = mock.calls.ClearChain
	mock.lockClearChain.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *IPTablesHandlerMock) Delete(table string, chain string, rulespec ...string) error {
	if mock.DeleteFunc == nil {
		panic("IPTablesHandlerMock.DeleteFunc: method is nil but IPTablesHandler.Delete was just called")
	}
	callInfo := struct {
		Table    string
		Chain    string
		Rulespec []string
	}{
		Table:    table,
		Chain:    chain,
		Rulespec: rulespec,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(table, chain, rulespec...)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedIPTablesHandler.DeleteCalls())
func (mock *IPTablesHandlerMock) DeleteCalls() []struct {
	Table    string
	Chain    string
	Rulespec []string
} {
	var calls []struct {
		Table    string
		Chain    string
		Rulespec []string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeleteAll calls DeleteAllFunc.
func (mock *IPTablesHandlerMock) DeleteAll() error {
	if mock.DeleteAllFunc == nil {
		panic("IPTablesHandlerMock.DeleteAllFunc: method is nil but IPTablesHandler.DeleteAll was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDeleteAll.Lock()
	mock.calls.DeleteAll = append(mock.calls.DeleteAll, callInfo)
	mock.lockDeleteAll.Unlock()
	return mock.DeleteAllFunc()
}

// DeleteAllCalls gets all the calls that were made to DeleteAll.
// Check the length with:
//
//	len(mockedIPTablesHandler.DeleteAllCalls())
func (mock *IPTablesHandlerMock) DeleteAllCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDeleteAll.RLock()
	calls = mock.calls.DeleteAll
	mock.lockDeleteAll.RUnlock()
	return calls
}

// DeleteChain calls DeleteChainFunc.
func (mock *IPTablesHandlerMock) DeleteChain(table string, chain string) error {
	if mock.DeleteChainFunc == nil {
		panic("IPTablesHandlerMock.DeleteChainFunc: method is nil but IPTablesHandler.DeleteChain was just called")
	}
	callInfo := struct {
		Table string
		Chain string
	}{
		Table: table,
		Chain: chain,
	}
	mock.lockDeleteChain.Lock()
	mock.calls.DeleteChain = append(mock.calls.DeleteChain, callInfo)
	mock.lockDeleteChain.Unlock()
	return mock.DeleteChainFunc(table, chain)
}

// DeleteChainCalls gets all the calls that were made to DeleteChain.
// Check the length with:
//
//	len(mockedIPTablesHandler.DeleteChainCalls())
func (mock *IPTablesHandlerMock) DeleteChainCalls() []struct {
	Table string
	Chain string
} {
	var calls []struct {
		Table string
		Chain string
	}
	mock.lockDeleteChain.RLock()
	calls = mock.calls.DeleteChain
	mock.lockDeleteChain.RUnlock()
	return calls
}

// DeleteIfExists calls DeleteIfExistsFunc.
func (mock *IPTablesHandlerMock) DeleteIfExists(table string, chain string, rulespec ...string) error {
	if mock.DeleteIfExistsFunc == nil {
		panic("IPTablesHandlerMock.DeleteIfExistsFunc: method is nil but IPTablesHandler.DeleteIfExists was just called")
	}
	callInfo := struct {
		Table    string
		Chain    string
		Rulespec []string
	}{
		Table:    table,
		Chain:    chain,
		Rulespec: rulespec,
	}
	mock.lockDeleteIfExists.Lock()
	mock.calls.DeleteIfExists = append(mock.calls.DeleteIfExists, callInfo)
	mock.lockDeleteIfExists.Unlock()
	return mock.DeleteIfExistsFunc(table, chain, rulespec...)
}

// DeleteIfExistsCalls gets all the calls that were made to DeleteIfExists.
// Check the length with:
//
//	len(mockedIPTablesHandler.DeleteIfExistsCalls())
func (mock *IPTablesHandlerMock) DeleteIfExistsCalls() []struct {
	Table    string
	Chain    string
	Rulespec []string
} {
	var calls []struct {
		Table    string
		Chain    string
		Rulespec []string
	}
	mock.lockDeleteIfExists.RLock()
	calls = mock.calls.DeleteIfExists
	mock.lockDeleteIfExists.RUnlock()
	return calls
}

// Exists calls ExistsFunc.
func (mock *IPTablesHandlerMock) Exists(table string, chain string, rulespec ...string) (bool, error) {
	if mock.ExistsFunc == nil {
		panic("IPTablesHandlerMock.ExistsFunc: method is nil but IPTablesHandler.Exists was just called")
	}
	callInfo := struct {
		Table    string
		Chain    string
		Rulespec []string
	}{
		Table:    table,
		Chain:    chain,
		Rulespec: rulespec,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(table, chain, rulespec...)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//	len(mockedIPTablesHandler.ExistsCalls())
func (mock *IPTablesHandlerMock) ExistsCalls() []struct {
	Table    string
	Chain    string
	Rulespec []string
} {
	var calls []struct {
		Table    string
		Chain    string
		Rulespec []string
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// GetIptablesVersion calls GetIptablesVersionFunc.
func (mock *IPTablesHandlerMock) GetIptablesVersion() (int, int, int) {
	if mock.GetIptablesVersionFunc == nil {
		panic("IPTablesHandlerMock.GetIptablesVersionFunc: method is nil but IPTablesHandler.GetIptablesVersion was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetIptablesVersion.Lock()
	mock.calls.GetIptablesVersion = append(mock.calls.GetIptablesVersion, callInfo)
	mock.lockGetIptablesVersion.Unlock()
	return mock.GetIptablesVersionFunc()
}

// GetIptablesVersionCalls gets all the calls that were made to GetIptablesVersion.
// Check the length with:
//
//	len(mockedIPTablesHandler.GetIptablesVersionCalls())
func (mock *IPTablesHandlerMock) GetIptablesVersionCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetIptablesVersion.RLock()
	calls = mock.calls.GetIptablesVersion
	mock.lockGetIptablesVersion.RUnlock()
	return calls
}

// HasRandomFully calls HasRandomFullyFunc.
func (mock *IPTablesHandlerMock) HasRandomFully() bool {
	if mock.HasRandomFullyFunc == nil {
		panic("IPTablesHandlerMock.HasRandomFullyFunc: method is nil but IPTablesHandler.HasRandomFully was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHasRandomFully.Lock()
	mock.calls.HasRandomFully = append(mock.calls.HasRandomFully, callInfo)
	mock.lockHasRandomFully.Unlock()
	return mock.HasRandomFullyFunc()
}

// HasRandomFullyCalls gets all the calls that were made to HasRandomFully.
// Check the length with:
//
//	len(mockedIPTablesHandler.HasRandomFullyCalls())
func (mock *IPTablesHandlerMock) HasRandomFullyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHasRandomFully.RLock()
	calls = mock.calls.HasRandomFully
	mock.lockHasRandomFully.RUnlock()
	return calls
}

// Insert calls InsertFunc.
func (mock *IPTablesHandlerMock) Insert(table string, chain string, pos int, rulespec ...string) error {
	if mock.InsertFunc == nil {
		panic("IPTablesHandlerMock.InsertFunc: method is nil but IPTablesHandler.Insert was just called")
	}
	callInfo := struct {
		Table    string
		Chain    string
		Pos      int
		Rulespec []string
	}{
		Table:    table,
		Chain:    chain,
		Pos:      pos,
		Rulespec: rulespec,
	}
	mock.lockInsert.Lock()
	mock.calls.Insert = append(mock.calls.Insert, callInfo)
	mock.lockInsert.Unlock()
	return mock.InsertFunc(table, chain, pos, rulespec...)
}

// InsertCalls gets all the calls that were made to Insert.
// Check the length with:
//
//	len(mockedIPTablesHandler.InsertCalls())
func (mock *IPTablesHandlerMock) InsertCalls() []struct {
	Table    string
	Chain    string
	Pos      int
	Rulespec []string
} {
	var calls []struct {
		Table    string
		Chain    string
		Pos      int
		Rulespec []string
	}
	mock.lockInsert.RLock()
	calls = mock.calls.Insert
	mock.lockInsert.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *IPTablesHandlerMock) List(table string, chain string) ([]string, error) {
	if mock.ListFunc == nil {
		panic("IPTablesHandlerMock.ListFunc: method is nil but IPTablesHandler.List was just called")
	}
	callInfo := struct {
		Table string
		Chain string
	}{
		Table: table,
		Chain: chain,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(table, chain)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedIPTablesHandler.ListCalls())
func (mock *IPTablesHandlerMock) ListCalls() []struct {
	Table string
	Chain string
} {
	var calls []struct {
		Table string
		Chain string
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// ListChains calls ListChainsFunc.
func (mock *IPTablesHandlerMock) ListChains(table string) ([]string, error) {
	if mock.ListChainsFunc == nil {
		panic("IPTablesHandlerMock.ListChainsFunc: method is nil but IPTablesHandler.ListChains was just called")
	}
	callInfo := struct {
		Table string
	}{
		Table: table,
	}
	mock.lockListChains.Lock()
	mock.calls.ListChains = append(mock.calls.ListChains, callInfo)
	mock.lockListChains.Unlock()
	return mock.ListChainsFunc(table)
}

// ListChainsCalls gets all the calls that were made to ListChains.
// Check the length with:
//
//	len(mockedIPTablesHandler.ListChainsCalls())
func (mock *IPTablesHandlerMock) ListChainsCalls() []struct {
	Table string
} {
	var calls []struct {
		Table string
	}
	mock.lockListChains.RLock()
	calls = mock.calls.ListChains
	mock.lockListChains.RUnlock()
	return calls
}

// ListWithCounters calls ListWithCountersFunc.
func (mock *IPTablesHandlerMock) ListWithCounters(table string, chain string) ([]string, error) {
	if mock.ListWithCountersFunc == nil {
		panic("IPTablesHandlerMock.ListWithCountersFunc: method is nil but IPTablesHandler.ListWithCounters was just called")
	}
	callInfo := struct {
		Table string
		Chain string
	}{
		Table: table,
		Chain: chain,
	}
	mock.lockListWithCounters.Lock()
	mock.calls.ListWithCounters = append(mock.calls.ListWithCounters, callInfo)
	mock.lockListWithCounters.Unlock()
	return mock.ListWithCountersFunc(table, chain)
}

// ListWithCountersCalls gets all the calls that were made to ListWithCounters.
// Check the length with:
//
//	len(mockedIPTablesHandler.ListWithCountersCalls())
func (mock *IPTablesHandlerMock) ListWithCountersCalls() []struct {
	Table string
	Chain string
} {
	var calls []struct {
		Table string
		Chain string
	}
	mock.lockListWithCounters.RLock()
	calls = mock.calls.ListWithCounters
	mock.lockListWithCounters.RUnlock()
	return calls
}

// NewChain calls NewChainFunc.
func (mock *IPTablesHandlerMock) NewChain(table string, chain string) error {
	if mock.NewChainFunc == nil {
		panic("IPTablesHandlerMock.NewChainFunc: method is nil but IPTablesHandler.NewChain was just called")
	}
	callInfo := struct {
		Table string
		Chain string
	}{
		Table: table,
		Chain: chain,
	}
	mock.lockNewChain.Lock()
	mock.calls.NewChain = append(mock.calls.NewChain, callInfo)
	mock.lockNewChain.Unlock()
	return mock.NewChainFunc(table, chain)
}

// NewChainCalls gets all the calls that were made to NewChain.
// Check the length with:
//
//	len(mockedIPTablesHandler.NewChainCalls())
func (mock *IPTablesHandlerMock) NewChainCalls() []struct {
	Table string
	Chain string
} {
	var calls []struct {
		Table string
		Chain string
	}
	mock.lockNewChain.RLock()
	calls = mock.calls.NewChain
	mock.lockNewChain.RUnlock()
	return calls
}

// ParseStat calls ParseStatFunc.
func (mock *IPTablesHandlerMock) ParseStat(stat []string) (iptables.Stat, error) {
	if mock.ParseStatFunc == nil {
		panic("IPTablesHandlerMock.ParseStatFunc: method is nil but IPTablesHandler.ParseStat was just called")
	}
	callInfo := struct {
		Stat []string
	}{
		Stat: stat,
	}
	mock.lockParseStat.Lock()
	mock.calls.ParseStat = append(mock.calls.ParseStat, callInfo)
	mock.lockParseStat.Unlock()
	return mock.ParseStatFunc(stat)
}

// ParseStatCalls gets all the calls that were made to ParseStat.
// Check the length with:
//
//	len(mockedIPTablesHandler.ParseStatCalls())
func (mock *IPTablesHandlerMock) ParseStatCalls() []struct {
	Stat []string
} {
	var calls []struct {
		Stat []string
	}
	mock.lockParseStat.RLock()
	calls = mock.calls.ParseStat
	mock.lockParseStat.RUnlock()
	return calls
}

// Proto calls ProtoFunc.
func (mock *IPTablesHandlerMock) Proto() iptables.Protocol {
	if mock.ProtoFunc == nil {
		panic("IPTablesHandlerMock.ProtoFunc: method is nil but IPTablesHandler.Proto was just called")
	}
	callInfo := struct {
	}{}
	mock.lockProto.Lock()
	mock.calls.Proto = append(mock.calls.Proto, callInfo)
	mock.lockProto.Unlock()
	return mock.ProtoFunc()
}

// ProtoCalls gets all the calls that were made to Proto.
// Check the length with:
//
//	len(mockedIPTablesHandler.ProtoCalls())
func (mock *IPTablesHandlerMock) ProtoCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockProto.RLock()
	calls = mock.calls.Proto
	mock.lockProto.RUnlock()
	return calls
}

// RenameChain calls RenameChainFunc.
func (mock *IPTablesHandlerMock) RenameChain(table string, oldChain string, newChain string) error {
	if mock.RenameChainFunc == nil {
		panic("IPTablesHandlerMock.RenameChainFunc: method is nil but IPTablesHandler.RenameChain was just called")
	}
	callInfo := struct {
		Table    string
		OldChain string
		NewChain string
	}{
		Table:    table,
		OldChain: oldChain,
		NewChain: newChain,
	}
	mock.lockRenameChain.Lock()
	mock.calls.RenameChain = append(mock.calls.RenameChain, callInfo)
	mock.lockRenameChain.Unlock()
	return mock.RenameChainFunc(table, oldChain, newChain)
}

// RenameChainCalls gets all the calls that were made to RenameChain.
// Check the length with:
//
//	len(mockedIPTablesHandler.RenameChainCalls())
func (mock *IPTablesHandlerMock) RenameChainCalls() []struct {
	Table    string
	OldChain string
	NewChain string
} {
	var calls []struct {
		Table    string
		OldChain string
		NewChain string
	}
	mock.lockRenameChain.RLock()
	calls = mock.calls.RenameChain
	mock.lockRenameChain.RUnlock()
	return calls
}

// Stats calls StatsFunc.
func (mock *IPTablesHandlerMock) Stats(table string, chain string) ([][]string, error) {
	if mock.StatsFunc == nil {
		panic("IPTablesHandlerMock.StatsFunc: method is nil but IPTablesHandler.Stats was just called")
	}
	callInfo := struct {
		Table string
		Chain string
	}{
		Table: table,
		Chain: chain,
	}
	mock.lockStats.Lock()
	mock.calls.Stats = append(mock.calls.Stats, callInfo)
	mock.lockStats.Unlock()
	return mock.StatsFunc(table, chain)
}

// StatsCalls gets all the calls that were made to Stats.
// Check the length with:
//
//	len(mockedIPTablesHandler.StatsCalls())
func (mock *IPTablesHandlerMock) StatsCalls() []struct {
	Table string
	Chain string
} {
	var calls []struct {
		Table string
		Chain string
	}
	mock.lockStats.RLock()
	calls = mock.calls.Stats
	mock.lockStats.RUnlock()
	return calls
}

// StructuredStats calls StructuredStatsFunc.
func (mock *IPTablesHandlerMock) StructuredStats(table string, chain string) ([]iptables.Stat, error) {
	if mock.StructuredStatsFunc == nil {
		panic("IPTablesHandlerMock.StructuredStatsFunc: method is nil but IPTablesHandler.StructuredStats was just called")
	}
	callInfo := struct {
		Table string
		Chain string
	}{
		Table: table,
		Chain: chain,
	}
	mock.lockStructuredStats.Lock()
	mock.calls.StructuredStats = append(mock.calls.StructuredStats, callInfo)
	mock.lockStructuredStats.Unlock()
	return mock.StructuredStatsFunc(table, chain)
}

// StructuredStatsCalls gets all the calls that were made to StructuredStats.
// Check the length with:
//
//	len(mockedIPTablesHandler.StructuredStatsCalls())
func (mock *IPTablesHandlerMock) StructuredStatsCalls() []struct {
	Table string
	Chain string
} {
	var calls []struct {
		Table string
		Chain string
	}
	mock.lockStructuredStats.RLock()
	calls = mock.calls.StructuredStats
	mock.lockStructuredStats.RUnlock()
	return calls
}
